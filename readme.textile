h1. Introduction to datatype.js

h2. Defining new types

Often you want class like things but writing your objects in the following manner is kind of tedious:

<pre>
var MyClass = function() {
    this.foo = "foo";
    this.bar = "bar";
};

MyClass.prototype.baz = function() {
    ...
}

MyClass.prototype.woz = function() {
    ...
}
</pre>

Using datatype.js you can instead write the following:

<pre>
var MyClass = _.datatype({
    initialize: function() {
       this.foo = "foo";
       this.bar = "bar";
    },

    baz: function () {
    },

    woz: function() {
    }
});
</pre>

h2. Protocols

Often you'll have a chunk of functionality that does not belong to a particular class. You can define a set of methods like so:

<pre>
var Events = _.protocol({
    addEvent: function(type, fn) { ... },
    removeEvent: function(type, fn) { ... },
    removeEvents: function(type) { ... },
    fireEvent: function(type) { ... }
});
</pre>

And "mixin" in this functionality easily:

<pre>
var Foo = _.datatype({
    protocols: [Events],
    intialize: function () {
        ...      
    } 
});
</pre>

h2. Polymorphism

datatype.js doesn't support datatype inheritance of any kind. However it is sometimes useful to reuse a name. For this purpose there is <code>_.multi</code>. You can use this like so:

<pre>
var Foo = _.datatype();
var Bar = _.datatype();

_.multi("cool", Foo, function(x) {
    console.log("got type Foo!");
});

_.multi("cool", Bar, function(x) {
    console.log("got type Bar!");
});

var a = new Foo();
var b = new Bar();

_.cool(a);
_.cool(b);
</pre>

With the above code the following also works great:

<pre>
_([a, b]).map(_.cool);
</pre>