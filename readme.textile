h1. Introduction to datatype.js

h2. Defining new types

Often you want class like things but writing your objects in the following manner is kind of tedious:

<pre>
var MyClass = function() {
    this.foo = "foo";
    this.bar = "bar";
};

MyClass.prototype.baz = function() {
    ...
}

MyClass.prototype.woz = function() {
    ...
}
</pre>

Using datatype.js you can instead write the following:

<pre>
var MyClass = _.Type({
    initialize: function() {
       this.foo = "foo";
       this.bar = "bar";
    },

    baz: function () {
    },

    woz: function() {
    }
});
</pre>

h2. Protocols

Often you'll have a chunk of functionality that does not belong to a particular class. You can define a set of methods like so:

<pre>
var Events = _.Protocol({
    addEvent: function(type, fn) { ... },
    removeEvent: function(type, fn) { ... },
    removeEvents: function(type) { ... },
    fireEvent: function(type) { ... }
});
</pre>

And "mixin" in this functionality easily:

<pre>
var Foo = _.Type({
    protocols: [Events],
    intialize: function () {
        ...      
    } 
});
</pre>

h2. Messaging

Being able to package up a message is pretty useful, especially at cutting down the amount of typing that you have to do. All methods of a Type are added to <code>_sel</code> so you use them with Underscore's excellent interfaces to the JavaScript collections.

<pre>
var Foo = _.Type({
  initialize: function(z) {
    this.z = z;
  },
  add: function(x, y) {
    return [x, y].join("");
  }
});
var Bar = _.Type({
  initialize: function(z) {
    this.z = z;
  },
  add: function(x, y) {
    return x + y + thiz.z;
  }
});

var a = new Foo("cool!");
var b = new Bar(6);

_([a, b]).map(_sel.add(4, 5));
</pre>